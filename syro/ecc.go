package syro

var eccTable = [...]uint8{
	0x00, 0x55, 0x56, 0x03, 0x59, 0x0C, 0x0F, 0x5A, 0x5A, 0x0F, 0x0C, 0x59, 0x03, 0x56, 0x55, 0x00,
	0x65, 0x30, 0x33, 0x66, 0x3C, 0x69, 0x6A, 0x3F, 0x3F, 0x6A, 0x69, 0x3C, 0x66, 0x33, 0x30, 0x65,
	0x66, 0x33, 0x30, 0x65, 0x3F, 0x6A, 0x69, 0x3C, 0x3C, 0x69, 0x6A, 0x3F, 0x65, 0x30, 0x33, 0x66,
	0x03, 0x56, 0x55, 0x00, 0x5A, 0x0F, 0x0C, 0x59, 0x59, 0x0C, 0x0F, 0x5A, 0x00, 0x55, 0x56, 0x03,
	0x69, 0x3C, 0x3F, 0x6A, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6A, 0x3F, 0x3C, 0x69,
	0x0C, 0x59, 0x5A, 0x0F, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0F, 0x5A, 0x59, 0x0C,
	0x0F, 0x5A, 0x59, 0x0C, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0C, 0x59, 0x5A, 0x0F,
	0x6A, 0x3F, 0x3C, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3C, 0x3F, 0x6A,
	0x6A, 0x3F, 0x3C, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3C, 0x3F, 0x6A,
	0x0F, 0x5A, 0x59, 0x0C, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0C, 0x59, 0x5A, 0x0F,
	0x0C, 0x59, 0x5A, 0x0F, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0F, 0x5A, 0x59, 0x0C,
	0x69, 0x3C, 0x3F, 0x6A, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6A, 0x3F, 0x3C, 0x69,
	0x03, 0x56, 0x55, 0x00, 0x5A, 0x0F, 0x0C, 0x59, 0x59, 0x0C, 0x0F, 0x5A, 0x00, 0x55, 0x56, 0x03,
	0x66, 0x33, 0x30, 0x65, 0x3F, 0x6A, 0x69, 0x3C, 0x3C, 0x69, 0x6A, 0x3F, 0x65, 0x30, 0x33, 0x66,
	0x65, 0x30, 0x33, 0x66, 0x3C, 0x69, 0x6A, 0x3F, 0x3F, 0x6A, 0x69, 0x3C, 0x66, 0x33, 0x30, 0x65,
	0x00, 0x55, 0x56, 0x03, 0x59, 0x0C, 0x0F, 0x5A, 0x5A, 0x0F, 0x0C, 0x59, 0x03, 0x56, 0x55, 0x00,
}

func ECC(bs []byte) uint32 {
	var eccReg1, eccReg2, eccReg3, ecc1, ecc2, bitPatA, bitPatB, ci uint8
	var ecc uint32

	eccReg1, eccReg2, eccReg3 = 0, 0, 0
	for i, b := range bs {
		ci = eccTable[b]
		eccReg1 ^= ci
		if ci&0x40 != 0 {
			eccReg3 ^= uint8(i)
			eccReg2 ^= uint8(i)
		}
	}

	ecc1, ecc2 = 0, 0
	bitPatA, bitPatB = 0x80, 0x80
	for i := 0; i < 4; i++ {
		if eccReg3&bitPatA != 0 {
			ecc1 |= bitPatB
		}
		bitPatB >>= uint64(1)
		if eccReg2&bitPatA != 0 {
			ecc1 |= bitPatB
		}
		bitPatB >>= uint64(1)
		bitPatA >>= uint64(1)
	}

	bitPatB = 0x80
	for i := 0; i < 4; i++ {
		if eccReg3&bitPatA != 0 {
			ecc2 |= bitPatB
		}
		bitPatB >>= uint64(1)
		if eccReg2&bitPatA != 0 {
			ecc2 |= bitPatB
		}
		bitPatB >>= uint64(1)
		bitPatA >>= uint64(1)
	}

	eccReg1 = (eccReg1 << uint64(2)) | 3
	ecc = uint32(eccReg1)
	ecc <<= uint64(8)
	ecc |= uint32(ecc2)
	ecc <<= uint64(8)
	ecc |= uint32(ecc1)

	return ecc
}
